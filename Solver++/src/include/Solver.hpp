/*
 * Solver.h
 *
 *  Created on: 3 wrz 2015
 *      Author: tomasz
 */

#ifndef SOLVER_HPP_
#define SOLVER_HPP_

#include "Typedefs.hpp"

#include <list>
#include <regex>
#include <string>
#include <unordered_map>

#include "exp/VariableModelExeptions.hpp"

#include "Typedefs.hpp"

class ParamIdxMapper;

class VariableIdxMapper;

class RowIdxMapper;

class OsiProblemInstance;

class Variable;

/** @brief Based class that handles model creation.
 *
 * @details Example above will describe entire process of model creation.
 *
 * Example of LP model:
 * @code
 *	minimize -1 x1 - 1 x2 - 2 y1 - 3 y2 - 4 z1
 *	s.t       1 x1 + 2 x2 <= 3		// 1st row
 *            2 x1 + 1 x2 <= 3		// 2nd row
 *           		 2 y1 <= 3		// 3th row
 *            3 y2 - 2 z1 => 3		// 4th row
 *              x1        >= 0
 *              x2        >= 0
 *       5 >=	y1        >= -5
 *      10 >=	y2        >= -10
 *      1 >=	z1        >= 0
 * @endcode
 *
 * Equivalent model generated by Solver class:
 * @code
 *	minimize -1 x1 - 1 x2 - 2 y1 - 3 y2 - 4 z1
 *	s.t       1 x1 + 2 x2 + 0 y1 + 0 y2 + 0 z1 <= 3		// 1st row
 *            2 x1 + 1 x2 + 0 y1 + 0 y2 + 0 z1 <= 3		// 2nd row
 *            0 x1 + 0 x2 + 2 y1 + 0 y2 + 0 z1 <= 3		// 3th row
 *            0 x1 + 0 x2 + 0 y1 + 3 y2 + (-2) z1 => 3	// 4th row
 *              x0        >= 0
 *              x1        >= 0
 *       5 >=	y1        >= -5
 *      10 >=	y2        >= -10
 *      1 >=	z1        >= 0
 * @endcode
 *
 * Code that will generate above model:
 *
 * @code
 *	Solver s(SolverInterface::GLPK);
 *
 * @endcode
 *
 */
class Solver {

private:

	//************************************ PRIVATE CONSTANT FIELDS *************************************//

	/** @brief Will accept only strings that consist of variables group's name
	 * followed by any number of indexes enclosed in Solver::DIM_GROUP_DELIMETERS.
	 *
	 * Name of group of variables has to consist of at least one character
	 * that is a English letter, number or underscore ("_").
	 *
	 */
	const static std::regex VAR_REGEXP;

	/** @brief Index value for group name of variable.
	 *
	 * @details By parsing variable's definition, two matches will be found.
	 * This variable holds predefined index for the first part of that definition.
	 *
	 * Example:
	 * 	@code
	 * 		Given a variable definition: x[2][3]:
	 * 		std::regex_search("x[2][3]", variableMatch, Solver::VAR_REGEXP);
	 * 		std::cout << variableMatch[VAR_REGEX_NAME_GROUP_IDX]; //will print "x"
	 * 	@endcode
	 *
	 */
	const static int VAR_REGEX_NAME_GROUP_IDX;

	/** @brief Index value for group name of variable.
	 *
	 * @details By parsing variable's definition, two matches will be found.
	 * This variable holds predefined index for the first part of that definition.
	 *
	 * Example:
	 * 	@code
	 * 		Given a variable definition: x[2][3]:
	 * 		std::regex_search("x[2][3]", variableMatch, Solver::VAR_REGEXP);
	 * 		std::cout << variableMatch[VAR_REGEX_DIM_GROUP_IDX]; //will print "[2][3]"
	 * 	@endcode
	 *
	 */
	const static int VAR_REGEX_DIM_GROUP_IDX;


	//***************************************** CLASS FIELDS *******************************************//

	/** @brief Reference to a selected solver engine.
	 *
	 * @details The actual solver interface is chosen by constructor of this class Solver(SolverInterface).
	 *
	 * @see SolverInterface enumeration of all possible engines that one can use if it is installed
	 *
	 */
	OsiProblemInstance* problemInstance;

	/** @brief Maps each parameter base name to data of this parameter's group.
	 *
	 * @details Every parameter has it's own base name and each parameter's name can represent
	 * any-dimensional structure of parameters with the same name
	 * indexed by any number (equal to group dimension) of indexes.
	 *
	 * Before every attempt to solve LP/MIP problem each parameter that is assignment to some variable
	 * will be mapped into several Osi-specific arrays
	 * based on information that this unordered_map contains.
	 *
	 * Example:
	 * @code
	 * 	Solver s(SolverInterface::GLPK);
	 * 	s.newParameter("p[4][5]");	//will add {"p", ParamIdxMapper} to parameters map.
	 * 								//ParamIdxMapper will store all details about this parameter (e.g. its dimension).
	 * @endcode
	 *
	 * @see OsiProblemInstance
	 * @see ParamIdxMapper
	 *
	 */
	std::unordered_map<std::string, ParamIdxMapper*>* parameters;

	/** @brief Maps each variable base name to data of this variable's group.
	 *
	 * @details Every variable has it's own base name and each variable's name can represent
	 * any-dimensional structure of variables with the same name
	 * indexed by any number (equal to group dimension) of indexes.
	 *
	 * Before every attempt to solve LP/MIP problem each variable in every group
	 * will be mapped into several Osi-specific arrays
	 * based on information that this unordered_map contains.
	 *
	 * Example:
	 * @code
	 * 	Solver s(SolverInterface::GLPK);
	 * 	s.newVariable("x[4][5]");	//will add {"x", VariableIdxMapper} to variables map.
	 * 								//VariableIdxMapper will store all details about this variable (e.g. its dimension).
	 * @endcode
	 *
	 * @see OsiProblemInstance
	 * @see VariableIdxMapper
	 *
	 */
	std::unordered_map<std::string, VariableIdxMapper*>* variables;

	/** @brief Maps each row base name to data of this row's group.
	 *
	 * @details Every row has it's own base name and each name can represent
	 * any-dimensional structure of rows with the same name
	 * indexed by any number (equal to group dimension) of indexes.
	 *
	 * Before every attempt to solve LP/MIP problem each row in every group
	 * will be mapped into several Osi-specific arrays
	 * based on information that this unordered_map contains.
	 *
	 * Example:
	 * @code
	 * 	Solver s(SolverInterface::GLPK);
	 * 	s.newVariable("row[4][5]");	//will add {"row", RowIdxMapper} to rows map.
	 * 								//RowIdxMapper will store all details about this set of rows (e.g. its dimension).
	 * @endcode
	 *
	 * Grouping rows can be used as easy way to group linear constraints that are related to same set of variables such like:
	 *
	 * @code
	 * 	forall (i in 1..4, j in 1..5) {
	 * 		...
	 * 	}
	 * @endcode
	 * piece of model written in OPL language.
	 *
	 * @see OsiProblemInstance
	 * @see RowIdxMapper
	 *
	 */
	std::unordered_map<std::string, RowIdxMapper*>* rows;

	//*************************************** PRIVATE FUNCTIONS ****************************************//

	/** @brief Extends column size of linear equations/inequalities in LP/MIP problem by given number
	 * after creating new group of variables.
	 *
	 * @details This is private function that is called by any member of the newVariable() functions' family.
	 *
	 * Example:
	 * @code
	 * 	Given problem instance with 2 variables: x[2], all coefficients equal 0 and one linear constraint:
	 * 	min 0 * x1 + 0 * x2
	 * 	s.t. 0 * x1 + 0 * x2 = 0
	 *
	 * 	By creating new variable (e.g. by calling  newVariable("y[3]")) this function will add them to model, giving:
	 * 	min 0 * x1 + 0 * x2 + 0 * y1 + 0 * y2 + 0 * y3
	 * 	s.t. 0 * x1 + 0 * x2 + 0 * y1 + 0 * y2 + 0 * y3 = 0
	 * @endcode
	 *
	 * @param numberOfNewVariables number of variables that will be added to model
	 *
	 */
	void addNumberOfVariables(const VarIdx& numberOfNewVariables);

	/** @brief Transform dimensional part of definition of group of variables into list of dimensions.
	 *
	 * @details If given variableDimensionDefinition is a definition of 0-dimensional variable (without indexes)
	 * then empty list will be returned.
	 *
	 * This is private method that is called by any member of the newVariable() functions' family.
	 *
	 * Example:
	 * @code
	 * 	Given variable definition: x[2][3].
	 * 	Calling this method will result in returning a given list: {2, 3}
	 * @endcode
	 *
	 * @param variableDimensionDefinition dimensional part of variable's definition
	 *
	 * @return list of dimensions retrieved from dimensional part of variable's definition
	 *
	 */
	std::list<VarDimIdx> getVariableDimensionList(
			const char* variableDimensionDefinition);

	/** @brief Counts number of all variables in given group based on it's dimensional part of definition
	 * that was transformed into list by getVariableDimensionList() function.
	 *
	 * @details If given dimensions list is empty then '1' will be returned as empty dimensions list
	 * refers to 0-dimensional variable (single variable without indexes)
	 *
	 * Example:
	 * @code
	 *	countVariablesInGroup({2,3,4});	// return a product of given numbers: 2*3*4 = 24
	 * @endcode
	 *
	 * @param dimensions list of dimensions of group of variables
	 *
	 * @return number of variables that is defined by previously transformed dimensional part of its definition.
	 *
	 */
	VarIdx countVariablesInGroup(const std::list<VarDimIdx>& dimensions);

	/** @brief Inserts given group of variables into variables map with matchedNameOfVariable as a key.
	 *
	 * @details If group of variables with the same name has been already added, group with this name will not be updated.
	 * This is private method that is called by any member of the newVariable() functions' family.
	 *
	 * @param matchedNameOfVariable base name of a matched variable
	 * @param numberOfVariables number of variables be added
	 * @param listOfDimensions list of given variable's dimensions
	 * @param lowerBound the smallest value that can be assign to any of variables among given group
	 * @param upperBound the greatest value that can be assign to any of variables among given group
	 * @param variableType type of variable
	 *
	 * @throw VariableModelExceptions::DuplicateException will be thrown in case in #variables
	 * there is already such an element with given name (another group of variables with the same base name was previously created).
	 *
	 * @see ValueType
	 *
	 */
	void insertVariable(const std::string& matchedNameOfVariable,
			const VarIdx numberOfVariables,
			const std::list<VarDimIdx>& listOfDimensions,
			const VarValue lowerBound, const VarValue upperBound,
			const ValueType variableType)
					throw (VariableModelExceptions::DuplicateException);

	/** @brief Return VariableIdxMapper of given variable.
	 *
	 * @details Wrapper function for map.at() function that will throw custom exception
	 * if there is no such an variable with given base name in #variables map.
	 *
	 * @param groupOfVariablesName base name of group of variables
	 * @return group of variables with given base name if such group exists
	 *
	 * @throw VariableModelExceptions::NoSuchGroupException will be raised
	 * if in the #variables map there is no such a group of variables with given name.
	 *
	 */
	VariableIdxMapper* getVariableIdxMapperAt(
			const std::string& groupOfVariablesName)
					throw (VariableModelExceptions::NoSuchGroupException);

public:

	//************************************* PUBLIC CONSTANT FIELDS *************************************//

	//************************************ CONSTRUCTOR & DESTRUCTOR ************************************//

	/** @brief Return instance of Solver for given solver engine.
	 *
	 * @details Depending on given #SolverInterface, constructor will create appropriate OsiSolverInterface.
	 * It will also extract minimum and maximum value for all structures' domains ( '∞' and '∞')
	 * that are solver-depended. From now on one can build model for specific problem by calling Solver methods.
	 * It will be translated by OsiSolverInterface to be solved by selected solver.
	 *
	 * Example:
	 * @code
	 * 	Solver s(SolverInterface::GLPK);	// will create new OsiGlpkSolverInterface as a solver.
	 * @endcode
	 *
	 * @param solverInterface
	 */
	Solver(SolverInterface solverInterface);

	virtual ~Solver();

	//*************************************** PUBLIC FUNCTIONS *****************************************//

	/** @brief Creates new variable according to given definition.
	 *
	 * @details For example calling:
	 * @code
	 * Solver s(SolverInterface::GLPK);
	 * s.newVariable("x");			// will create new variable x,
	 * s.newVariable("x[3][4]");	// 3x4 matrix of variables named x.
	 * @endcode
	 *
	 * New variable/variables have neither upper nor lower bound and they have double type by default.
	 *
	 * @param variableDefinition full definition of variable to be created
	 *
	 * @throw VariableModelExceptions::DuplicateException will be thrown in case
	 * already exists a group of variables with the same base name.
	 * @throw VariableModelExceptions::InvalidGroupDefinitionException will be thrown in case
	 * variableDefinition is not a valid definition of group of variables/variable.
	 *
	 * @see #VAR_REGEXP
	 *
	 */
	void newVariable(const std::string& variableDefinition)
			throw (VariableModelExceptions::DuplicateException,
			VariableModelExceptions::InvalidGroupDefinitionException);

	/** @brief Creates new variable according to given definition.
	 *
	 * @details For example calling:
	 * @code
	 * Solver s(SolverInterface::GLPK);
	 * s.newVariable("x", ValueType::BINARY);		// will create new integer variable x bounded by 0 and 1,
	 * s.newVariable("x", ValueType::INTEGER);		// will create new integer variable x,
	 * s.newVariable("x[3][4]", ValueType::DOUBLE);	// 3x4 matrix of variables named x with default type.
	 * @endcode
	 *
	 * New variable/variables have neither upper nor lower bound.
	 *
	 * Due to MIP solver specification every integer variable will be created
	 * as double and only after successfully finding of first LP solution (first upper/lower bound)
	 * will be transformed into integer variable in order to find MIP solution of given problem.
	 *
	 * @param variableDefinition full definition of variable to be created
	 * @param variableType type of variable
	 *
	 * @throw VariableModelExceptions::DuplicateException will be thrown in case
	 * already exists a group of variables with the same base name.
	 * @throw VariableModelExceptions::InvalidGroupDefinitionException will be thrown in case
	 * variableDefinition is not a valid definition of group of variables/variable.
	 *
	 * @see #VAR_REGEXP
	 * @see ValueType
	 *
	 */
	void newVariable(const std::string& variableDefinition,
			const ValueType variableType)
					throw (VariableModelExceptions::DuplicateException,
					VariableModelExceptions::InvalidGroupDefinitionException);

	/** @brief Creates new bounded variable according to given definition and given type.
	 *
	 * @details For example calling:
	 * @code
	 * Solver s(SolverInterface::GLPK);
	 * s.newVariable("x", 0, 1, ValueType::INTEGER);	// will create new integer variable x
	 * 													// bounded by 0 and 1 (which is basically bounds of binary variable),
	 * s.newVariable("x[3]", 0,
	 * 	Utils::getUnbounded(Bounds::UPPER),
	 * 	ValueType::DOUBLE
	 * );	// array of 3 variables named x with default type,
	 * 		// without upper bound where s is a given Solver,
	 * s.newVariable("x[3][4]",
	 * 	Utils::getUnbounded(Bounds::LOWER),
	 * 	Utils::getUnbounded(Bounds::UPPER),
	 * 	ValueType::DOUBLE
	 * );	// 3x4 matrix of unbounded variables named x with default type.
	 * @endcode
	 *
	 * If given lower or upper bounds is set to floating point number
	 * and variable type is not of that type (#BINARY, #INTEGER)
	 * then given bounds will be automatically rounded down to nearest valid value.
	 *
	 * Due to MIP solver specification every integer variable will be created
	 * as double and only after successfully finding of first LP solution (first upper/lower bound)
	 * will be transformed into integer variable in order to find MIP solution of given problem.
	 *
	 * @param variableDefinition full definition of variable to be created
	 * @param variableLowerBound the smallest value that can be assign to any of variables among given group
	 * @param variableUpperBound the greatest value that can be assign to any of variables among given group
	 * @param variableType type of variable
	 *
	 * @throw VariableModelExceptions::DuplicateException will be thrown in case
	 * already exists a group of variables with the same base name.
	 * @throw VariableModelExceptions::InvalidGroupDefinitionException will be thrown in case
	 * variableDefinition is not a valid definition of group of variables/variable.
	 *
	 * @see #VAR_REGEXP
	 * @see ValueType
	 * @see Utils::getUnbounded()
	 *
	 */
	void newVariable(const std::string& variableDefinition,
			const VarValue variableLowerBound,
			const VarValue variableUpperBound, const ValueType variableType)
					throw (VariableModelExceptions::DuplicateException,
					VariableModelExceptions::InvalidGroupDefinitionException);

	/** @brief Removes every group of variables available.
	 *
	 * @details Removes every VariableIdxMapper instance in variables map.
	 *
	 */
	void deleteAllVariables();

	/** @brief Removes entire group of variables.
	 *
	 * @details It will remove given group of variables from groups' map (@see variables)
	 * and after that delete object from memory itself.
	 *
	 * @param variableName base name of a group of variables to be deleted
	 * @throw std::out_of_range is thrown if no such variable is defined.
	 */
	void deleteVariable(const char* variableName) throw (std::out_of_range);

	/** @brief Returns a reference to variable that matched given variableDefinition.
	 *
	 * @details For 0-dimensional variable e.g. "x" there are two valid forms: "x" and "x[1]".
	 *
	 * Example:
	 * @code
	 * Solver s(SolverInterface::GLPK);
	 * s.getVariable("x");			// will return a reference to the variable "x"
	 * s.getVariable("x[1]");		// will return a reference to the variable "x"
	 * s.getVariable("y[2]");		// will return a reference to the variable "y[2]"
	 * s.getVariable("z[1][2][3]");	// will return a reference to the variable "z[1][2][3]"
	 * @endcode
	 *
	 * @param variableDefinition definition of one particular variable e.g. "x[3]".
	 *
	 * @return reference to variable defined by variableDefinition
	 *
	 * @throw std::out_of_range If no such group of variable is defined.
	 * @throw InvalidNumberOfDimensionIndexesException If group of variables was found
	 * but has different number of dimensions then given in variableDefinition.
	 * @throw IndexOutOfBoundException If one or more indexes in given definition
	 * extends dimension sizes of group of variables.
	 * @throw InvalidVariableDefinitionException General error is thrown
	 * when given variableDefinition is not a definition of group of variables (does not match #VAR_REGEXP).
	 */
	Variable& getVariable(const std::string& variableDefinition)
			throw (std::out_of_range,
			VariableModelExceptions::InvalidNumberOfDimensionIndexesException,
			VariableModelExceptions::IndexOutOfBoundException,
			VariableModelExceptions::InvalidDefinitionException);

	/** @brief Returns a reference to variable that matched given variableDefinition.
	 *
	 * @details This method allows to input variables as indexes of given variableDefinition.
	 * For 0-dimensional variables there is no option to retrieve them
	 * by using of definition without any indexes since at least one
	 * have to be defined as firstDimensionIndex. Also variableDefinition
	 * have to have the same number of pair of brackets as inputed number of indexes.
	 *
	 * Example:
	 * @code
	 * Solver s(SolverInterface::GLPK);
	 * s.getVariable("y[]",2);			// will return a reference to the variable "y[2]"
	 * s.getVariable("z[][][]",1,2,3);	// will return a reference to the variable "z[1][2][3]"
	 * @endcode
	 *
	 * @param variableDefinition definition of variable with empty brackets.
	 * @param firstDimensionIndex index of the highest dimension (the first one after base name)
	 *
	 * @return reference to variable defined by variableDefinition and given indexes.
	 *
	 * @throw std::out_of_range If no such group of variable is defined.
	 * @throw InvalidNumberOfDimensionIndexesException If group of variables was found
	 * but has different number of dimensions then given in variableDefinition.
	 * @throw IndexOutOfBoundException If one or more indexes in given definition
	 * extends dimension sizes of group of variables.
	 * @throw InvalidVariableDefinitionException General error is thrown
	 * when given variableDefinition is not a definition of group of variables (@see VAR_REGEXP).
	 */
	Variable& getVariable(const std::string& variableDefinition,
			VarDimIdx firstDimensionIndex,
			...) throw (std::out_of_range,
					VariableModelExceptions::InvalidNumberOfDimensionIndexesException,
					VariableModelExceptions::IndexOutOfBoundException);

	//*************************************** GETTERS & SETTERS ****************************************//

	/** @brief Return number of variables in this model.
	 *
	 * @return number of variables in this model
	 */
	VarIdx getNumberOfVariables() const;

};

#endif /* SOLVER_HPP_ */
